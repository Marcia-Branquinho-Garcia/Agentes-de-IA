# -*- coding: utf-8 -*-
"""Meu Projeto

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NRzgIMryc8oXV9Y78UU8-tMSLT2GqTYG
"""

# Commented out IPython magic to ensure Python compatibility.
# Parte 1: Configura√ß√£o Inicial
# %pip install -q google-genai google-adk requests python-dotenv

# Configurar a API Key do Google Gemini
import os
from google.colab import userdata

# Configure sua API key aqui
os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY')

# Importar bibliotecas necess√°rias
from google import genai
from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.genai import types

import re
import json
import random
import textwrap
from datetime import date
from IPython.display import display, Markdown, HTML
import warnings
import requests

warnings.filterwarnings("ignore")

# Inicializar o cliente do Google Genai
client = genai.Client()
MODEL_ID = "gemini-2.0-flash"

# Fun√ß√£o auxiliar para chamar agentes
def call_agent(agent: Agent, message_text: str) -> str:
    """Chama um agente e retorna sua resposta como texto"""
    session_service = InMemorySessionService()
    session = session_service.create_session(app_name=agent.name, user_id="user1", session_id="session1")
    runner = Runner(agent=agent, app_name=agent.name, session_service=session_service)
    content = types.Content(role="user", parts=[types.Part(text=message_text)])

    final_response = ""
    for event in runner.run(user_id="user1", session_id="session1", new_message=content):
        if event.is_final_response():
          for part in event.content.parts:
            if part.text is not None:
              final_response += part.text
              final_response += "\n"
    return final_response

# Fun√ß√£o auxiliar para exibir texto formatado
def to_markdown(text):
    """Exibe texto formatado em markdown"""
    text = text.replace('‚Ä¢', '  *')
    return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

print("‚úÖ Configura√ß√£o inicial conclu√≠da com sucesso!")

# Parte 2: Agentes de Idea√ß√£o e Texto

# Agente de Idea√ß√£o
class IdeacaoAgent:
    def __init__(self):
        self.agent = Agent(
            name="agente_ideacao",
            model=MODEL_ID,
            description="Agente que gera ideias criativas para conte√∫do crist√£o",
            tools=[google_search],
            instruction="""
            Voc√™ √© um especialista em conte√∫do crist√£o/b√≠blico e gera√ß√£o de ideias criativas.

            Sua tarefa √© analisar o tema b√≠blico fornecido e gerar ideias originais e
            envolventes que possam ser desenvolvidas em v√≠deos para um canal crist√£o no YouTube.

            Para cada ideia gerada:
            1. Forne√ßa um t√≠tulo atraente e inspirador
            2. Apresente uma breve descri√ß√£o (2-3 frases)
            3. Explique por que essa abordagem seria eficaz para o p√∫blico crist√£o

            Use a ferramenta de busca para pesquisar interpreta√ß√µes b√≠blicas,
            coment√°rios teol√≥gicos e exemplos de conte√∫do crist√£o bem-sucedido.

            Suas sugest√µes devem ser fi√©is ao texto b√≠blico, mas tamb√©m relevantes
            para a vida contempor√¢nea, especialmente para mulheres crist√£s.

            Numere cada ideia claramente (1., 2., etc.) e separe-as por linhas em branco.

            IMPORTANTE: Todo o conte√∫do deve ser em portugu√™s brasileiro, adequado para
            um p√∫blico crist√£o contempor√¢neo.
            """
        )

    def gerar_ideias(self, tema, plataforma, quantidade=5):
        """Gera ideias para conte√∫do baseado em tema b√≠blico"""
        print(f"üß† Gerando ideias para '{tema}' na plataforma '{plataforma}'...")

        entrada = f"""
        Tema b√≠blico: {tema}
        Plataforma: {plataforma}
        Quantidade de ideias: {quantidade}

        Gere ideias criativas para v√≠deos crist√£os sobre este tema,
        relacionados √† B√≠blia e √† f√© crist√£. O conte√∫do ser√° para
        um canal crist√£o no YouTube, voltado para adultos.

        Por favor, gere apenas em portugu√™s brasileiro.
        """

        ideias = call_agent(self.agent, entrada)
        return ideias


# Agente de Gera√ß√£o de Texto
class TextoAgent:
    def __init__(self):
        self.agent = Agent(
            name="agente_texto",
            model=MODEL_ID,
            description="Agente que gera conte√∫do textual para v√≠deos crist√£os",
            tools=[google_search],
            instruction="""
            Voc√™ √© um redator especializado em conte√∫do crist√£o/b√≠blico.

            Sua tarefa √© desenvolver roteiros e textos para v√≠deos crist√£os no YouTube,
            com base na ideia fornecida.

            O texto deve ser:
            1. Fiel √†s Escrituras e teologicamente s√≥lido
            2. Bem estruturado, com introdu√ß√£o, desenvolvimento por t√≥picos e conclus√£o
            3. Envolvente e inspirador para o p√∫blico crist√£o
            4. Inclua refer√™ncias b√≠blicas espec√≠ficas (cap√≠tulo e vers√≠culo)

            Use a ferramenta de busca para pesquisar vers√≠culos b√≠blicos, coment√°rios
            teol√≥gicos e informa√ß√µes contextuais que enrique√ßam o conte√∫do.

            Utilize formata√ß√£o em markdown com t√≠tulos (# e ##) para estruturar o texto
            em se√ß√µes que possam ser facilmente convertidas em timestamps para o v√≠deo.

            IMPORTANTE: Todo o conte√∫do deve ser em portugu√™s brasileiro, em um tom
            acolhedor e inspirador adequado para um p√∫blico crist√£o.
            """
        )

    def gerar_texto(self, ideia, tom, tamanho, plataforma):
        """Gera texto completo baseado na ideia selecionada"""
        print(f"üìù Gerando texto com tom '{tom}' e tamanho '{tamanho}'...")

        # Mapear tamanhos para contagens aproximadas de palavras
        tamanhos = {
            "curto": "600-800 palavras (5-7 minutos de v√≠deo)",
            "m√©dio": "1000-1500 palavras (8-12 minutos de v√≠deo)",
            "longo": "2000-2500 palavras (15-20 minutos de v√≠deo)"
        }

        palavra_count = tamanhos.get(tamanho.lower(), tamanhos["m√©dio"])

        entrada = f"""
        Ideia para v√≠deo crist√£o: {ideia}
        Tom: {tom}
        Tamanho: {palavra_count}
        Plataforma: {plataforma}

        Desenvolva um roteiro completo para um v√≠deo crist√£o no YouTube,
        baseado na ideia acima. Inclua:

        1. Um t√≠tulo envolvente e crist√£o
        2. Uma introdu√ß√£o que conecte com o p√∫blico e apresente o tema
        3. Desenvolvimento por t√≥picos com refer√™ncias b√≠blicas espec√≠ficas
        4. Aplica√ß√µes pr√°ticas para a vida crist√£ contempor√¢nea
        5. Uma conclus√£o inspiradora com chamada para a√ß√£o

        Use formata√ß√£o markdown com # para t√≠tulo principal e ## para se√ß√µes
        que servir√£o como timestamps no v√≠deo.

        Inclua tamb√©m uma breve ora√ß√£o relacionada ao tema no final.
        """

        texto = call_agent(self.agent, entrada)
        return texto

    def extrair_palavras_chave(self, texto, quantidade=5):
        """Extrai palavras-chave do texto para SEO"""
        palavras_chave_agent = Agent(
            name="agente_palavras_chave",
            model=MODEL_ID,
            description="Agente que extrai palavras-chave para SEO crist√£o",
            instruction=f"""
            Extraia as {quantidade} palavras-chave mais relevantes do texto crist√£o fornecido.
            Essas palavras-chave devem ser relevantes para SEO de conte√∫do crist√£o no YouTube.

            Inclua termos b√≠blicos, conceitos teol√≥gicos e express√µes que pessoas crist√£s
            buscariam no YouTube relacionadas ao tema.

            Retorne apenas as palavras-chave, uma por linha, sem numera√ß√£o ou outros textos.
            As palavras-chave devem ser em portugu√™s.
            """
        )

        # Limitar o texto para evitar problemas com tamanho
        texto_resumido = texto[:3000] + "..." if len(texto) > 3000 else texto

        palavras = call_agent(palavras_chave_agent, texto_resumido)

        # Extrair apenas as palavras-chave, uma por linha
        keywords = [line.strip() for line in palavras.split('\n') if line.strip()]

        # Limitar ao n√∫mero solicitado
        return keywords[:quantidade]

print("‚úÖ Agentes de Idea√ß√£o e Texto configurados com sucesso!")

# Parte 3: Agente de Edi√ß√£o

class EditorAgent:
    def __init__(self):
        self.agent = Agent(
            name="agente_editor",
            model=MODEL_ID,
            description="Agente que edita e otimiza conte√∫do para YouTube crist√£o",
            tools=[google_search],
            instruction="""
            Voc√™ √© um editor profissional especializado em conte√∫do crist√£o para YouTube.

            Sua tarefa √© revisar, editar e aprimorar o roteiro do v√≠deo, considerando:
            1. Clareza e coer√™ncia da mensagem b√≠blica
            2. Estrutura e fluidez da narrativa para um v√≠deo
            3. Otimiza√ß√£o para SEO no YouTube (se palavras-chave fornecidas)
            4. Corre√ß√£o teol√≥gica e fidelidade √†s Escrituras

            Use a ferramenta de busca para pesquisar vers√≠culos b√≠blicos,
            coment√°rios teol√≥gicos e melhores pr√°ticas para v√≠deos crist√£os no YouTube.

            Mantenha a ess√™ncia da mensagem original, mas melhore a apresenta√ß√£o,
            ritmo e impacto para um v√≠deo envolvente.

            Formate o texto final em markdown, mantendo a estrutura de t√≠tulos para timestamps.

            Tamb√©m crie uma descri√ß√£o otimizada para o v√≠deo no YouTube e
            sugest√µes de tags relevantes para o p√∫blico crist√£o.
            """
        )

    def otimizar(self, texto, plataforma, palavras_chave=None):
        """Edita e otimiza o conte√∫do para o YouTube"""
        print(f"‚úÇÔ∏è Editando e otimizando o conte√∫do para '{plataforma}'...")

        info_seo = ""
        if palavras_chave and len(palavras_chave) > 0:
            info_seo = f"Palavras-chave para SEO crist√£o: {', '.join(palavras_chave)}"

        entrada = f"""
        Roteiro do v√≠deo a ser otimizado:
        {texto}

        Plataforma: {plataforma}

        {info_seo}

        Revise e otimize este roteiro para um v√≠deo crist√£o no YouTube.

        1. Mantenha a estrutura de t√≠tulos (# e ##) para timestamps
        2. Verifique as refer√™ncias b√≠blicas e corrija se necess√°rio
        3. Melhore a introdu√ß√£o para captar aten√ß√£o nos primeiros 15 segundos
        4. Otimize para SEO usando as palavras-chave fornecidas
        5. Crie uma descri√ß√£o atraente para o v√≠deo (at√© 2000 caracteres)
        6. Sugira 10 tags relevantes para o YouTube

        Mantenha o conte√∫do teologicamente s√≥lido e fiel √† mensagem b√≠blica.
        """

        texto_otimizado = call_agent(self.agent, entrada)

        # Formatar o conte√∫do final para o YouTube
        conteudo_formatado = self._formatar_youtube(texto_otimizado)

        return conteudo_formatado

    def _formatar_youtube(self, texto):
        """Processa o texto otimizado para extrair informa√ß√µes importantes para YouTube"""
        linhas = texto.split('\n')
        titulo = ""
        descricao = ""
        roteiro = texto
        topicos = []
        timestamps = []
        tags = []

        # Estado para capturar diferentes se√ß√µes
        capturando_descricao = False
        capturando_tags = False
        tempo_atual = "00:00"

        # Processar linha por linha
        for linha in linhas:
            # Capturar t√≠tulo principal
            if linha.startswith("# ") and not titulo:
                titulo = linha[2:]

            # Capturar subt√≠tulos para timestamps
            elif linha.startswith("## "):
                subtitulo = linha[3:]
                topicos.append(subtitulo)
                timestamps.append(f"{tempo_atual} - {subtitulo}")

                # Simular incremento de tempo
                minutos, segundos = map(int, tempo_atual.split(':'))
                minutos += 2  # Adiciona 2 minutos por se√ß√£o
                if minutos >= 60:
                    minutos %= 60
                tempo_atual = f"{minutos:02d}:{segundos:02d}"

            # Capturar descri√ß√£o
            elif "descri√ß√£o" in linha.lower() or "description" in linha.lower():
                capturando_descricao = True
                capturando_tags = False
                continue

            # Capturar tags
            elif "tags" in linha.lower() or "hashtags" in linha.lower():
                capturando_descricao = False
                capturando_tags = True
                continue

            # Processar linha com base no estado
            if capturando_descricao and linha.strip() and not linha.startswith("#"):
                descricao += linha + "\n"
            elif capturando_tags and linha.strip() and not linha.startswith("#"):
                # Processar linha de tags
                if "," in linha:
                    # Tags separadas por v√≠rgula
                    tags.extend([tag.strip() for tag in linha.split(",") if tag.strip()])
                elif "#" in linha:
                    # Tags com hashtag
                    tags.extend([tag.strip() for tag in linha.split() if tag.strip().startswith("#")])
                else:
                    # Tags separadas por espa√ßo
                    tags.extend([tag.strip() for tag in linha.split() if tag.strip()])

        # Se n√£o encontrou descri√ß√£o expl√≠cita, usar o in√≠cio do texto
        if not descricao:
            for linha in linhas:
                if not linha.startswith("#") and linha.strip():
                    descricao += linha + "\n"
                    if len(descricao) > 500:
                        break

        # Adicionar informa√ß√µes padr√£o √† descri√ß√£o
        descricao += "\n\n===================================\n"
        descricao += "üîî INSCREVA-SE NO CANAL: [URL DO CANAL]\n"
        descricao += "üëç DEIXE SEU LIKE e COMPARTILHE\n"
        descricao += "üí¨ COMENTE sua opini√£o ou d√∫vidas abaixo\n\n"

        # Adicionar timestamps na descri√ß√£o
        if timestamps:
            descricao += "‚è±Ô∏è TIMESTAMPS:\n"
            for ts in timestamps:
                descricao += ts + "\n"

        # Se n√£o encontrou tags suficientes, adicionar algumas padr√µes para conte√∫do crist√£o
        if len(tags) < 5:
            tags_padrao = ["B√≠blia", "Prov√©rbios 31", "mulher virtuosa", "cristianismo",
                          "devocional", "estudo b√≠blico", "mulher crist√£", "vers√≠culos"]
            tags.extend(tags_padrao)

        # Limitar a 10 tags
        tags = tags[:10]

        # Criar o objeto formatado
        return {
            "tipo": "youtube",
            "titulo": titulo,
            "descricao": descricao,
            "tags": tags,
            "timestamps": timestamps,
            "roteiro": roteiro,
            "info_adicional": "Conte√∫do para YouTube sobre a Mulher de Prov√©rbios 31"
        }

print("‚úÖ Agente de Edi√ß√£o configurado com sucesso!")

# Parte 4: Assistente Principal Simplificado (sem imagens)

class AssistenteConteudoSimplificado:
    def __init__(self):
        self.ideacao = IdeacaoAgent()
        self.texto = TextoAgent()
        self.editor = EditorAgent()

        # Armazenar resultados intermedi√°rios
        self.ideias = ""
        self.ideia_selecionada = ""
        self.texto_gerado = ""
        self.palavras_chave = []
        self.conteudo_final = {}

    def iniciar(self):
        """Inicia o processo simplificado (sem imagens)"""
        print("üöÄ Assistente de Cria√ß√£o de Conte√∫do para YouTube Crist√£o üöÄ")
        print("===========================================================")

        try:
            # 1. Obter tema
            tema = input("\nüìù Digite o tema b√≠blico para o conte√∫do (ex: A Mulher de Prov√©rbios 31): ")
            if not tema:
                tema = "A Mulher de Prov√©rbios 31: virtudes e li√ß√µes para a mulher crist√£ contempor√¢nea"
                print(f"Usando tema padr√£o: {tema}")

            # 2. Gerar ideias
            print("\n‚ú® Etapa 1: Gerando ideias criativas...\n")
            self.ideias = self.ideacao.gerar_ideias(tema, "youtube", 5)
            display(to_markdown(self.ideias))

            # 3. Selecionar uma ideia
            print("\nüîç Digite o n√∫mero da ideia que voc√™ escolheu (ex: 1, 2, 3...):")

            # Criar uma ideia padr√£o para fallback
            ideia_padrao = f"Conte√∫do sobre {tema} para YouTube com foco crist√£o"

            # Extrair ideias numeradas
            ideias_extraidas = []
            linhas = self.ideias.split('\n')
            for i, linha in enumerate(linhas):
                if re.match(r'^\d+\.', linha.strip()):
                    resumo = linha.strip()
                    print(f"  Ideia {resumo[:100]}..." if len(resumo) > 100 else f"  {resumo}")
                    ideias_extraidas.append(resumo)

            # Se n√£o encontrou ideias, usar o texto completo
            if not ideias_extraidas:
                ideias_extraidas = [self.ideias]
                print(f"  1. Conte√∫do baseado nas sugest√µes geradas")

            # Selecionar ideia
            try:
                numero_ideia = int(input("> ")) - 1
                if 0 <= numero_ideia < len(ideias_extraidas):
                    self.ideia_selecionada = ideias_extraidas[numero_ideia]
                else:
                    print("‚ö†Ô∏è N√∫mero inv√°lido, usando a primeira ideia.")
                    self.ideia_selecionada = ideias_extraidas[0] if ideias_extraidas else ideia_padrao
            except:
                print("‚ö†Ô∏è Entrada inv√°lida, usando a primeira ideia.")
                self.ideia_selecionada = ideias_extraidas[0] if ideias_extraidas else ideia_padrao

            print(f"\n‚úÖ Ideia selecionada: {self.ideia_selecionada[:100]}..."
                  if len(self.ideia_selecionada) > 100 else f"\n‚úÖ Ideia selecionada: {self.ideia_selecionada}")

            # 4. Configura√ß√µes para gera√ß√£o de texto
            print("\nüìã Configurando a gera√ß√£o de texto...")

            tons = ["inspirador", "informativo", "pastoral", "evangel√≠stico", "devocional"]
            print("Tons dispon√≠veis:")
            for i, t in enumerate(tons):
                print(f"  {i+1}. {t.capitalize()}")

            try:
                tom_idx = int(input("Escolha o n√∫mero do tom (1-5): ")) - 1
                tom = tons[tom_idx] if 0 <= tom_idx < len(tons) else "inspirador"
            except:
                print("‚ö†Ô∏è Valor inv√°lido, usando tom Inspirador como padr√£o.")
                tom = "inspirador"

            tamanhos = ["curto", "m√©dio", "longo"]
            print("Tamanhos dispon√≠veis:")
            for i, t in enumerate(tamanhos):
                print(f"  {i+1}. {t.capitalize()}")

            try:
                tamanho_idx = int(input("Escolha o n√∫mero do tamanho (1-3): ")) - 1
                tamanho = tamanhos[tamanho_idx] if 0 <= tamanho_idx < len(tamanhos) else "m√©dio"
            except:
                print("‚ö†Ô∏è Valor inv√°lido, usando tamanho M√©dio como padr√£o.")
                tamanho = "m√©dio"

            # 5. Gerar texto
            print("\n‚ú® Etapa 2: Gerando texto para a ideia selecionada...\n")
            self.texto_gerado = self.texto.gerar_texto(self.ideia_selecionada, tom, tamanho, "youtube")
            display(to_markdown(self.texto_gerado))

            # 6. Extrair palavras-chave
            print("\nüîë Extraindo palavras-chave para SEO...")
            self.palavras_chave = self.texto.extrair_palavras_chave(self.texto_gerado, 8)
            print("Palavras-chave extra√≠das:")
            for kw in self.palavras_chave:
                print(f"  ‚Ä¢ {kw}")

            # 7. Edi√ß√£o e otimiza√ß√£o (sem imagens)
            print("\n‚ú® Etapa 3: Editando e otimizando o conte√∫do...\n")

            # Opcional: palavras-chave adicionais para SEO
            usar_seo = input("Deseja adicionar mais palavras-chave para SEO? (s/n): ").lower() == 's'
            if usar_seo:
                keywords_input = input("Digite palavras-chave adicionais (separadas por v√≠rgula): ")
                if keywords_input:
                    keywords_adicionais = [k.strip() for k in keywords_input.split(',')]
                    self.palavras_chave.extend(keywords_adicionais)
                    # Limitar a 10 palavras-chave
                    self.palavras_chave = self.palavras_chave[:10]

            # Otimizar conte√∫do
            self.conteudo_final = self.editor.otimizar(
                self.texto_gerado,
                "youtube",
                self.palavras_chave
            )

            # 8. Exibir resultado final
            self._exibir_conteudo_final()

            # 9. Salvar o conte√∫do
            self._salvar_conteudo()

        except Exception as e:
            print(f"‚ö†Ô∏è Ocorreu um erro: {e}")
            import traceback
            traceback.print_exc()

    def _exibir_conteudo_final(self):
        """Exibe o conte√∫do final formatado"""
        try:
            print("\nüéâ Conte√∫do Final para YouTube üéâ")
            print("===============================")

            titulo = self.conteudo_final.get("titulo", "")
            descricao = self.conteudo_final.get("descricao", "")
            tags = self.conteudo_final.get("tags", [])
            timestamps = self.conteudo_final.get("timestamps", [])
            roteiro = self.conteudo_final.get("roteiro", "")

            print(f"\nüìπ T√≠tulo do V√≠deo: {titulo}")

            print("\n‚è±Ô∏è Timestamps:")
            for ts in timestamps:
                print(f"  ‚Ä¢ {ts}")

            print("\nüè∑Ô∏è Tags:")
            print(f"  {', '.join(tags)}")

            print("\nüìù Descri√ß√£o:")
            print("-" * 50)
            print(descricao[:500] + "..." if len(descricao) > 500 else descricao)
            print("-" * 50)

            print("\nüìú Roteiro do V√≠deo:")
            display(to_markdown(roteiro))

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao exibir conte√∫do final: {e}")

    def _salvar_conteudo(self):
        """Salva o conte√∫do final em arquivos de texto"""
        salvar = input("\nDeseja salvar o conte√∫do gerado? (s/n): ").lower() == 's'

        if salvar:
            nome_base = input("Digite um nome base para os arquivos (ex: mulher_proverbios31): ")
            if not nome_base:
                nome_base = "conteudo_cristao"

            # Salvar roteiro em formato markdown
            with open(f"{nome_base}_roteiro.md", "w", encoding="utf-8") as f:
                f.write(self.conteudo_final.get("roteiro", ""))

            # Salvar descri√ß√£o e metadados em arquivo separado
            with open(f"{nome_base}_metadados.txt", "w", encoding="utf-8") as f:
                f.write(f"T√çTULO: {self.conteudo_final.get('titulo', '')}\n\n")
                f.write(f"DESCRI√á√ÉO:\n{self.conteudo_final.get('descricao', '')}\n\n")
                f.write(f"TAGS:\n{', '.join(self.conteudo_final.get('tags', []))}\n\n")
                f.write(f"TIMESTAMPS:\n")
                for ts in self.conteudo_final.get('timestamps', []):
                    f.write(f"{ts}\n")

            print(f"\n‚úÖ Conte√∫do salvo como '{nome_base}_roteiro.md' e '{nome_base}_metadados.txt'")

print("‚úÖ Assistente Principal configurado com sucesso!")

# Parte 5: Iniciar o Assistente

# Criar e iniciar o assistente
assistente = AssistenteConteudoSimplificado()
assistente.iniciar()